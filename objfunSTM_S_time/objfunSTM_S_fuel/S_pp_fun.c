/*
 * Academic License - for use in teaching, academic research, and meeting
 * course requirements at degree granting institutions only.  Not for
 * government, commercial, or other organizational use.
 *
 * S_pp_fun.c
 *
 * Code generation for function 'S_pp_fun'
 *
 */

/* Include files */
#include "S_pp_fun.h"
#include "objfunSTM_S_fuel_data.h"
#include "objfunSTM_S_fuel_types.h"
#include "rt_nonfinite.h"
#include "mwmathutil.h"
#include <string.h>

/* Variable Definitions */
static emlrtRSInfo dg_emlrtRSI = {
    15,                                                   /* lineNo */
    "S_pp_fun",                                           /* fcnName */
    "E:\\Users\\ricca\\Desktop\\codegen code\\S_pp_fun.m" /* pathName */
};

static emlrtBCInfo pd_emlrtBCI = {
    -1,                                                    /* iFirst */
    -1,                                                    /* iLast */
    10,                                                    /* lineNo */
    10,                                                    /* colNo */
    "in1",                                                 /* aName */
    "S_pp_fun",                                            /* fName */
    "E:\\Users\\ricca\\Desktop\\codegen code\\S_pp_fun.m", /* pName */
    0                                                      /* checkKind */
};

static emlrtBCInfo qd_emlrtBCI = {
    -1,                                                    /* iFirst */
    -1,                                                    /* iLast */
    9,                                                     /* lineNo */
    10,                                                    /* colNo */
    "in2",                                                 /* aName */
    "S_pp_fun",                                            /* fName */
    "E:\\Users\\ricca\\Desktop\\codegen code\\S_pp_fun.m", /* pName */
    0                                                      /* checkKind */
};

static emlrtBCInfo rd_emlrtBCI = {
    -1,                                                    /* iFirst */
    -1,                                                    /* iLast */
    8,                                                     /* lineNo */
    10,                                                    /* colNo */
    "in2",                                                 /* aName */
    "S_pp_fun",                                            /* fName */
    "E:\\Users\\ricca\\Desktop\\codegen code\\S_pp_fun.m", /* pName */
    0                                                      /* checkKind */
};

/* Function Definitions */
void S_pp_fun(const emlrtStack *sp, const emxArray_real_T *in1,
              const emxArray_real_T *in2, real_T Tsym, real_T d2S_dpdp[25])
{
  emlrtStack st;
  const real_T *in1_data;
  const real_T *in2_data;
  real_T t10;
  real_T t2;
  real_T t3;
  real_T t4;
  real_T t6;
  real_T t7;
  st.prev = sp;
  st.tls = sp->tls;
  in2_data = in2->data;
  in1_data = in1->data;
  /* S_pp_fun */
  /*     d2S_dpdp = S_pp_fun(IN1,IN2,Tsym,CSYM,EPSsym) */
  /*     This function was generated by the Symbolic Math Toolbox version 9.2.
   */
  /*     01-Sep-2024 17:26:09 */
  if (in2->size[0] < 3) {
    emlrtDynamicBoundsCheckR2012b(3, 1, in2->size[0], &rd_emlrtBCI,
                                  (emlrtConstCTX)sp);
  }
  if (in2->size[0] < 4) {
    emlrtDynamicBoundsCheckR2012b(4, 1, in2->size[0], &qd_emlrtBCI,
                                  (emlrtConstCTX)sp);
  }
  if (in1->size[0] < 5) {
    emlrtDynamicBoundsCheckR2012b(5, 1, in1->size[0], &pd_emlrtBCI,
                                  (emlrtConstCTX)sp);
  }
  t2 = in2_data[2] * in2_data[2];
  t3 = in2_data[3] * in2_data[3];
  t4 = 1.0 / in1_data[4];
  t6 = t2 + t3;
  st.site = &dg_emlrtRSI;
  if (t6 < 0.0) {
    emlrtErrorWithMessageIdR2018a(
        &st, &e_emlrtRTEI, "Coder:toolbox:ElFunDomainError",
        "Coder:toolbox:ElFunDomainError", 3, 4, 4, "sqrt");
  }
  t6 = muDoubleScalarSqrt(t6);
  t6 = 1.0 / t6;
  t7 = muDoubleScalarPower(t6, 3.0);
  t6 *= Tsym * t4;
  t10 = -(Tsym * in2_data[2] * in2_data[3] * t4 * t7);
  memset(&d2S_dpdp[0], 0, 12U * sizeof(real_T));
  d2S_dpdp[12] = t6 - Tsym * t2 * t4 * t7;
  d2S_dpdp[13] = t10;
  d2S_dpdp[14] = 0.0;
  d2S_dpdp[15] = 0.0;
  d2S_dpdp[16] = 0.0;
  d2S_dpdp[17] = t10;
  d2S_dpdp[18] = t6 - Tsym * t3 * t4 * t7;
  d2S_dpdp[19] = 0.0;
  d2S_dpdp[20] = 0.0;
  d2S_dpdp[21] = 0.0;
  d2S_dpdp[22] = 0.0;
  d2S_dpdp[23] = 0.0;
  d2S_dpdp[24] = 0.0;
}

/* End of code generation (S_pp_fun.c) */
