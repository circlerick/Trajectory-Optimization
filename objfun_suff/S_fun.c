/*
 * Academic License - for use in teaching, academic research, and meeting
 * course requirements at degree granting institutions only.  Not for
 * government, commercial, or other organizational use.
 *
 * S_fun.c
 *
 * Code generation for function 'S_fun'
 *
 */

/* Include files */
#include "S_fun.h"
#include "objfun_suff_data.h"
#include "rt_nonfinite.h"
#include "mwmathutil.h"

/* Variable Definitions */
static emlrtBCInfo ud_emlrtBCI = {
    -1,                                                 /* iFirst */
    -1,                                                 /* iLast */
    11,                                                 /* lineNo */
    10,                                                 /* colNo */
    "in1",                                              /* aName */
    "S_fun",                                            /* fName */
    "E:\\Users\\ricca\\Desktop\\codegen code\\S_fun.m", /* pName */
    0                                                   /* checkKind */
};

static emlrtBCInfo vd_emlrtBCI = {
    -1,                                                 /* iFirst */
    -1,                                                 /* iLast */
    10,                                                 /* lineNo */
    10,                                                 /* colNo */
    "in2",                                              /* aName */
    "S_fun",                                            /* fName */
    "E:\\Users\\ricca\\Desktop\\codegen code\\S_fun.m", /* pName */
    0                                                   /* checkKind */
};

static emlrtBCInfo wd_emlrtBCI = {
    -1,                                                 /* iFirst */
    -1,                                                 /* iLast */
    9,                                                  /* lineNo */
    10,                                                 /* colNo */
    "in2",                                              /* aName */
    "S_fun",                                            /* fName */
    "E:\\Users\\ricca\\Desktop\\codegen code\\S_fun.m", /* pName */
    0                                                   /* checkKind */
};

static emlrtBCInfo xd_emlrtBCI = {
    -1,                                                 /* iFirst */
    -1,                                                 /* iLast */
    8,                                                  /* lineNo */
    10,                                                 /* colNo */
    "in2",                                              /* aName */
    "S_fun",                                            /* fName */
    "E:\\Users\\ricca\\Desktop\\codegen code\\S_fun.m", /* pName */
    0                                                   /* checkKind */
};

/* Function Definitions */
real_T S_fun(const emlrtStack *sp, const real_T in1_data[], int32_T in1_size,
             const real_T in2_data[], int32_T in2_size, real_T Tsym,
             real_T csym)
{
  emlrtStack st;
  real_T t2;
  real_T x;
  st.prev = sp;
  st.tls = sp->tls;
  /* S_fun */
  /*     Ssym = S_fun(IN1,IN2,Tsym,CSYM,EPSsym) */
  /*     This function was generated by the Symbolic Math Toolbox version 9.2.
   */
  /*     01-Sep-2024 17:26:08 */
  if (in2_size < 3) {
    emlrtDynamicBoundsCheckR2012b(3, 1, in2_size, &xd_emlrtBCI,
                                  (emlrtConstCTX)sp);
  }
  if (in2_size < 4) {
    emlrtDynamicBoundsCheckR2012b(4, 1, 3, &wd_emlrtBCI, (emlrtConstCTX)sp);
  }
  if (in2_size < 5) {
    emlrtDynamicBoundsCheckR2012b(5, 1, 4, &vd_emlrtBCI, (emlrtConstCTX)sp);
  }
  if (in1_size < 5) {
    emlrtDynamicBoundsCheckR2012b(5, 1, in1_size, &ud_emlrtBCI,
                                  (emlrtConstCTX)sp);
  }
  t2 = 1.0 / csym;
  st.site = &v_emlrtRSI;
  x = in2_data[2] * in2_data[2] + in2_data[3] * in2_data[3];
  if (x < 0.0) {
    emlrtErrorWithMessageIdR2018a(
        &st, &d_emlrtRTEI, "Coder:toolbox:ElFunDomainError",
        "Coder:toolbox:ElFunDomainError", 3, 4, 4, "sqrt");
  }
  x = muDoubleScalarSqrt(x);
  return -Tsym * ((t2 + in2_data[4] * t2) - x / in1_data[4]);
}

/* End of code generation (S_fun.c) */
